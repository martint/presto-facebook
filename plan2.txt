SELECT a, b, SUM(a * c) + AVG(a * c)
FROM T
GROUP BY a, b

map(
	group(
		table('T', {'a', 'b', 'c'}),
		v0 -> {v0.0, v0.1}),
	v1 -> { v1.0.0, v1.0.1, sum(map(v1.1, v2 -> v2.0 * v2.2)) + avg(map(v1.1, v2 -> v2.0 * v2.2)) })



t0 = table(T, {a, b, c})
t1 = group(t0, v0 -> {v0.0, v0.1})
t2 = map(t1, v1 -> { v1.0.0, v1.0.1, sum(map(v1.1, v2 -> v2.0 * v2.2)) + avg(map(v1.1, v2 -> v2.0 * v2.2)) })



t0 = table('T', {'a', 'b', 'c'})
t1 = group(t0, v0 -> {v0.0, v0.1})
t2 = map(t1, v1 ->
	x1 = map(v1.1, v2 -> v2.0 * v2.2)
	u1 = sum(x1)
	x2 = map(v1.1, v2 -> v2.0 * v2.2)
	u2 = avg(x2)
	u3 = u1 + u2
	{ v1.0.0, v1.0.1, u3 })



*** hoist map() over bags of rows out of the enclosing map and do them before the group
*** this requires adding an intermediate map() that produces a rel with one field for each
*** group by key and one field for each map() that was hoisted

t0 = table('T', {'a', 'b', 'c'})
z0 = map(t0, v2 -> { v2.0, v2.1, v2.0 * v2.2, v2.0 * v2.2 })

t1 = group(z0, v0 -> {v0.0, v0.1})
t2 = map(t1, v1 ->
	u1 = sum(v1.1.0)
	u2 = avg(v1.1.1)
	u3 = u1 + u2
	{ v1.0.0, v1.0.1, u3 })

*** convert a group followed by map into a dictEncode followed by aggregate

t0 = table('T', {'a', 'b', 'c'})
z0 = map(t0, v2 -> { v2.0, v2.1, v2.0 * v2.2, v2.0 * v2.2 })

t3 = dictEncode(z0, v0 -> {v0.0, v0.1})     # produces a stream of {int, int, int, int, groupId}
t4 = aggregate(t3, v1 -> v1.groupId, { { sum, v1 -> v1.2) }, { avg, v1 -> v1.3 } }





t1 = group(z0, v0 -> {v0.0, v0.1})
t2 = map(t1, v1 ->
	u1 = sum(v1.1.0)
	u2 = avg(v1.1.1)
	u3 = u1 + u2
	{ v1.0.0, v1.0.1, u3 })








==== ????
aggregate(
	table(T, {a, b, c}),
	v0 -> {v0.0, v0.1}),                                                          # grouping function
	{ (acc, v1) -> sum(acc, v1.0 * v1.2), (acc, v2) -> avg(acc, v2.0 * v2.2) }    # aggregates

====

t :: Rel{int, int}

(a, b) = t

a :: Rel{int}
b :: Rel{int}



**** 1
t0 = table(T, {a, b, c})                    t0 :: Rel{int, int, int}
t1 = group(t0, v0 -> {v0.0, v0.1})          t1 :: Rel{{int,int}, Rel{int, int, int}}
r = project(t1, v1 -> { v1.0.0, v1.0.1, sum(project(v1.1, v2 -> v2.0 * v2.2)) + avg(project(v1.1, v2 -> v2.0 * v2.2)) })


**** 2
t0 = table(T, {a, b, c})
t1 = group(t0, v0 -> {v0.0, v0.1})
(t2, t3, t4) = project(t1, v1 -> { v1.0.0, v1.0.1, sum(project(v1.1, v2 -> v2.0 * v2.2)) + avg(project(v1.1, v2 -> v2.0 * v2.2)) })
r = concat(t2, t3, t4)

**** 3
t0 = table(T, {a, b, c})
t1 = group(t0, v0 -> {v0.0, v0.1})
t2 = project(t1, v1 -> v1.0.0)
t3 = project(t1, v1 -> v1.0.1)
t4 = project(t1, v1 -> sum(project(v1.1, v2 -> v2.0 * v2.2)) + avg(project(v1.1, v2 -> v2.0 * v2.2))
r = concat(t2, t3, t4)


**** 3.1

t0 = table(T, {a, b, c})
t1 = group(t0, v0 -> {v0.0, v0.1})
t2 = t1.0.0
t3 = t1.0.1
t4 = sum(project(t1.1, v2 -> v2.0 * v2.2)) + avg(project(t1.1, v2 -> v2.0 * v2.2))
r = concat(t2, t3, t4)

**** 4
t0 = table(T, {a, b, c})
t1 = group(t0, v0 -> {v0.0, v0.1})
t2 = t1.0.0
t3 = t1.0.1
t4 = sum(project(t1.1, v2 -> v2.0 * v2.2))
t5 = avg(project(t1.1, v2 -> v2.0 * v2.2))
t6 = t4 + t5
r = concat(t2, t3, t6)

**** 5
t0 = table(T, {a, b, c})
t1 = group(t0, v0 -> {v0.0, v0.1})
t2 = t1.0.0
t3 = t1.0.1
t7 = project(t1.1, v2 -> v2.0 * v2.2)
t4 = sum(t7)
t8 = project(t1.1, v2 -> v2.0 * v2.2)
t5 = avg(t8)
t6 = t4 + t5
r = concat(t2, t3, t6)

**** 6
t0 = table(T, {a, b, c})
t1 = group(t0, v0 -> {v0.0, v0.1})
t2 = t1.0.0
t3 = t1.0.1
t7 = project(t1.1, v2 -> v2.0 * v2.2)
t4 = sum(t7)
t5 = avg(t7)
t6 = t4 + t5
r = concat(t2, t3, t6)


**** 7
t0 = table(T, {a, b, c})
t1 = group(t0, v0 -> {v0.0, v0.1})
t2 = t1.0.0
t3 = t1.0.1
t7 = t1.1.0 * t1.1.2
t4 = sum(t7)
t5 = avg(t7)
t6 = t4 + t5
r = concat(t2, t3, t6)

**** 8
t0 = table(T, {a, b, c})
t1 = group(t0, v0 -> {v0.0, v0.1})
t7 = t1.1.0 * t1.1.2
t4 = sum(t7)
t5 = avg(t7)
t6 = t4 + t5
r = concat(t1.0.0, t1.0.1, t6)





SELECT a, b, SUM(a * c) + AVG(a * c)
FROM T
WHERE b > 50 AND c = 3
GROUP BY a, b
HAVING MAX(a) > 10















project(                                                       => Rel{bigint, bigint, bigint}
	group(                                                 => Rel{bigint, bigint, Rel{bigint, bigint, bigint}}
		project(                                       => Rel{bigint, bigint, bigint}
			table(T, {a, b, c}),                   => Rel{bigint, bigint, bigint}
			v0 -> {v0.0, v0.1, v0.0 * v0.2})),     => Rel{bigint, bigint, bigint} -> Rel{bigint, bigint, bigint}
		v2 -> { v2.0, v2.1 }))                         => Rel{bigint, bigint, bigint} -> Rel{bigint, bigint}
	v3 -> { v3.0, v3.1, sum(v3.2) })                       => Rel{bigint, bigint, Rel{bigint, bigint, bigint}} -> Rel{bigint, bigint, bigint}








table(T, {a,b,c}).map { |t| {a, b, a * c} }.reduce { |acc, {a, b, x}| acc[{a, b}] += x }.map { |acc,

table(T).map { |t| {t.a, t.b, t.a * t.c } }.groupBy { |t| {t.a, t.b } }.map { |{a, b}, v| {a, b, sum(v) }

project(
	group(
		table(T, {a, b, c}),
		v0 -> { v0.0, v0.1 },
		v1 -> { v1.0 * v1.2 }),
	v2 -> { v2.0, v2.1, sum(v2.3) })





aggregation(
	project(
		table(T, {a, b, c}),
		v0 -> {a, b, c, computeGroupId({v0.0, v0.1}) }
	v1 -> { v1.3 },
	v2 -> { accumulator[v2.3] += v2.0 * v2.2 }
	sum_agg(v2.key, v2.0 * v2.2)




table(tableName, tuple<columnNames>) -> Rel{a,b,c,…}

project(Rel{a,b,c,…}, (t) -> { x, y, z }) -> Rel{x, y, z}

group(Rel{a,b,c…}, (t) -> { x, y, z}) -> Rel{x,y,z, Rel{a,b,c…}}

dictEncoder(Rel{a,b,c,…}, (t) -> {x, y, z}) -> Rel{a,b,c,.., k}

aggregation(Rel{a,b,c,…,k}, (t) -> {k}, ((t) ->



for ({a,b,c} : T) {
   groupId = groups.getOrCreate({a, b})

   sum[groupId] += a * c;
}

for (groupId : groups) {
   {a, b} = groups.getKey(groupId)
   result.append({a, b, sum[groupId]})
}







aggregate(
	table(T, {a, b, c}),
	v0 -> { v0.0, v0.1 },  # group
	v1 -> { v1.0 * v1.2 },  # pre-project
	v2 -> { sum(v2.3) }, # aggregate
	v3 -> { v3.0, v3.1, v3.2 } # post-project



